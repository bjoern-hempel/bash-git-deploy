#!/usr/bin/env bash

# ------------
# Friends of Ba$h. A collection of useful bash functions. Easy to include in your bash scripts.
#
# @author    Björn Hempel <bjoern@hempel.li>
# @version   v0.0.0 (2018-04-02)
#
# @copyright MIT License
# @copyright
# @copyright Copyright (c) 2018 Björn Hempel
# @copyright
# @copyright Permission is hereby granted, free of charge, to any person obtaining a copy
# @copyright of this software and associated documentation files (the "Software"), to deal
# @copyright in the Software without restriction, including without limitation the rights
# @copyright to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
# @copyright copies of the Software, and to permit persons to whom the Software is
# @copyright furnished to do so, subject to the following conditions:
# @copyright
# @copyright The above copyright notice and this permission notice shall be included in all
# @copyright copies or substantial portions of the Software.
# @copyright
# @copyright THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# @copyright IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# @copyright FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
# @copyright AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# @copyright LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
# @copyright OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
# @copyright SOFTWARE.
# @copyright
# @copyright Written by Björn Hempel <bjoern@hempel.li>.
# ------------

# some configs
numberOfLastTags=15
currentName="current"
dumpsName="dumps"
dumpTemplate='%s/dump-%s.sql'
postExecuteTemplate='%s/.postExecute'

# db configs
dbhost=''
dbname=''
dbuser=''
dbpass=''

# some configs and informations
bashSource="${BASH_SOURCE[0]}"

if [ -L "$bashSource" ]; then
    bashSource=$(readlink "$bashSource")
fi

pathBin="$(cd "$(dirname "$bashSource")" && pwd)"
pathRoot=$(dirname $pathBin)
pathCurrent="$PWD"
gitLibPath="$pathRoot/lib/git"

# include some libraries
source "$gitLibPath"

# calculate some configs
currentPath="$pathCurrent/$currentName"
dumpsPath="$pathCurrent/$dumpsName"
postExecuteScript=$(printf "$postExecuteTemplate" "$pathCurrent")

# ------------
# Converts the given number to a letter.
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2018-04-02)
# ------------
function chr
{
    printf \\$(printf '%03o' $1)
}

# ------------
# Updates the tag list in given path.
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2018-04-02)
# ------------
function fetchTags
{
    local gitDir="$1"

    if [ "$gitDir" != "" ] && [ -d "$gitDir" ]; then
        cd "$gitDir"
    fi

    git fetch --tags
}

# ------------
# Checks out the given revision number.
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2018-04-02)
# ------------
function checkoutRevision
{
    local revision="$1"
    local gitDir="$2"

    if [ "$gitDir" != "" ] && [ -d "$gitDir" ]; then
        cd "$gitDir"
    fi

    local checkoutResult=$(git checkout $revision)

    return 0
}

# ------------
# Gets a list of last tags of given git repository.
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2018-04-02)
# ------------
function getListOfLastTags
{
    local gitDir="$1"
    local numberOfLastTags="$2"
    local filterTag=true

    if [ "$gitDir" != "" ] && [ -d "$gitDir" ]; then
        cd "$gitDir"
    fi

    # update the tag list
    fetchTags

    if $filterTag; then
        git log --tags --simplify-by-decoration --pretty="format:%H  %d   %ai" | grep "tag: " --color=never | head -n $numberOfLastTags
    else
        git log --simplify-by-decoration --pretty="format:%H  %d   %ai" | head -n $numberOfLastTags
    fi
}

# ------------
# Clones the current release folder and relocate the current symlink to the new copy.
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2018-04-02)
# ------------
function cloneReleaseFolderAndResymlink
{
    local $currentName="$1"

    rsync --progress --stats -avz $(readlink "$currentName")"/" "releases/"$(date '+%Y%m%d%H%M%S')
    rm "$currentName" && ln -s releases/$(ls -r releases/ | head -1) "$currentName"

    return 0
}

# ------------
# Returns the absolute target from given symlink.
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2018-04-04)
# ------------
function getAbsoluteTargetFromSymlink
{
    local symlink="$1"

    local absolutePath=$(realpath "$symlink")

    echo -n "$absolutePath"
}

# ------------
# Dumps the current db, prints messages and manages the dump files.
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2018-04-04)
# ------------
function dumpMysqlBatch
{
    local dbhost="$1"
    local dbname="$2"
    local dbuser="$3"
    local dbpass="$4"

    local dumpFile="$5"

    local neutralMessage="$6"
    local successMessage="$7"
    local errorMessage="$8"

    echo -n $(printf "$neutralMessage .." "$dumpFile")
    echo -n " "

    local dumpSuccessful=false

    if dumpMysql "$dbhost" "$dbname" "$dbuser" "$dbpass" "$dumpFile"; then
        dumpSuccessful=true
    fi

    # Delete dump file if an error occurred while dumping the db
    if ! $dumpSuccessful && [ -f "$dumpFile" ]; then
        rm "$dumpFile"
    fi

    # Prints out an error message.
    if [ ! -f "$dumpFile" ]; then
        echo $(printf "$errorMessage")
        return 1
    fi

    # Prints out a success message.
    echo $(printf "$successMessage")
    return 0
}

# ------------
# Dumps the current db.
#
# @author  Björn Hempel <bjoern@hempel.li>
# @version 1.0 (2018-04-04)
# ------------
function dumpMysql
{
    local dbhost="$1"
    local dbname="$2"
    local dbuser="$3"
    local dbpass="$4"

    local dumpFile="$5"

    local dumpStatus=0
    local dumpResult=""

    dumpResult=$(mysqldump -h$dbhost -u$dbuser -p$dbpass $dbname > $dumpFile 2>/dev/null)
    dumpStatus=$?

    if [ "$dumpStatus" -ne 0 ]; then
        return 1
    fi

    return 0
}

# check bash version
if [ "${BASH_VERSINFO}" -lt 4 ]; then
    echo "This library needs a bash version at least 4 or higher. Your version number: $BASH_VERSION. Please update your bash version."
    exit
fi

# show last n tags
listOfLastTags=$(getListOfLastTags "$currentPath" $numberOfLastTags)
currentRevision=$(getCurrentChangesetFromGivenPath "$currentPath")
currentTag=$(getCurrentTagFromGivenPath "$currentPath")
currentReleasePath=$(getAbsoluteTargetFromSymlink "$currentPath")
currentReleaseVersion=$(basename "$currentReleasePath")
currentDumpPath="$dumpsPath/$currentReleaseVersion"
currentDumpFile=$(printf "$dumpTemplate" "$currentDumpPath" $(date '+%Y%m%d%H%M%S'))

# print some infos
echo "Current path:              $currentPath"
echo "Current release path:      $currentReleasePath"
echo "Current installed version: $currentRevision (tag: $currentTag)"
echo "Current release version:   $currentReleaseVersion"
echo "Current dump path:         $currentDumpPath"
echo "Current dump file:         $currentDumpFile"
echo

# prepare some directories
if [ ! -d "$currentDumpPath" ]; then
    mkdir -p "$currentDumpPath"
fi

# declare some needed variables
declare -A revisions
counter=0

# list the last tags
while read -r line; do
    [ "$counter" -lt 10 ] && versionNumber=$counter || versionNumber=$(chr $((87 + counter)))

    revision=$(echo "$line" | awk '{print $1}')

    revisions[$versionNumber]=$revision

    [ "$revision" == "$currentRevision" ] && echo -n '→ ' || echo -n '  '
    echo $versionNumber")  "$line

    counter=$((counter+1))
done <<< "$listOfLastTags"

# select the wanted tag
echo
echo "Which new revision number you want to use?"
echo

while true; do
    read -n 1 -p "Choose the number above: " choice

    if [ "$choice" == $'\e' ]; then
        echo "Switch process was canceled by user."
        exit
    elif [ -v ${revisions[$choice]} ]; then
       echo && echo "The entered revision number $choice does not exist. Try another one."
    else
       break
    fi
done

revision=${revisions[$choice]}

echo && echo

while true; do
    echo -ne "I will checkout to revision number $revision. Continue? [yn]: "

    read -n 1 answer && echo

    # catch escape
    if [ "$answer" == $'\e' ]; then
        echo "Switch process was canceled by user."
        exit
    fi

    [[ "$answer" =~ [yn] ]] && break
done

echo

if [[ "$answer" =~ [n] ]]; then
    echo "Switch process was canceled by user."
    exit
fi

# dump mysql db (db backup)
if [ "$dbhost" != "" ] && [ "$dbname" != "" ] && [ "$dbuser" != "" ] && [ "$dbpass" != "" ] && [ "$currentDumpFile" != "" ]; then
    if ! dumpMysqlBatch "$dbhost" "$dbname" "$dbuser" "$dbpass" "$currentDumpFile" "Dump current db into file \"%s\"" "Successfully finished." "Error occurred while dumping db. Abort."; then
        echo "The db backup could not created successfully. Stop here. Didn't change the release."
        exit
    fi
else
    while true; do
        echo -ne "The db config is not correct or was not found. I will skip the db backup. Continue? [yn]: "

        read -n 1 answer && echo

        # catch escape
        if [ "$answer" == $'\e' ]; then
            echo "The script was canceled by user."
            exit
        fi

        if [[ "$answer" =~ [n] ]]; then
            echo "The script was canceled by user."
            exit
        fi

        [[ "$answer" =~ [y] ]] && break
    done
fi

# make copy of current direcory and add relocate the symlink
echo -n "Clone the current release folder.. "
cloneResult=$(cloneReleaseFolderAndResymlink "$currentName")
echo "Done." && echo

# only a message
echo -n "Relocate the symlink.. "
echo "Done." && echo

# checkout the wanted revision number into the new current folder
echo -n "Try to checkout new revision $revision.. "
checkoutResult=$(checkoutRevision "$revision" "$currentPath")
echo "Done." && echo

# check revision number
echo "Check the revision number.. "
currentRevision=$(getCurrentChangesetFromGivenPath "$currentPath")
currentTag=$(getCurrentTagFromGivenPath "$currentPath")

# success or error message
if [ "$currentRevision" == "$revision" ]; then
    echo "Revision $revision was successfully installed. Currently installed version: $currentRevision (tag: $currentTag)."
else
    echo "Revision $revision was not successfully installed. Currently installed version: $currentRevision (tag: $currentTag)."
fi

# execute post script
echo "Search for post execute script.. "
if [ -f "$postExecuteScript" ]; then
    echo "Found. Execute."
    source "$postExecuteScript"
    echo "Done."
else
    echo "Not found. Skip."
fi
echo

